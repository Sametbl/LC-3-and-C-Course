; The subroutine for INPUT and OUTPUT module used: Multi_digit INPUT .v4  +  Multi_digit OUTPUT .v3

.ORIG x3000
            LEA R0, msg
            PUTS
            JSR INPUT
            ST  R6, num

            LD  R0, TEN
            OUT
            LEA R0, msg2
            PUTS
            LD  R6, num
            JSR OUTPUT
            HALT
;---------------- The Subroutine -------------

INPUT            ST  R7, SAVE       ; Store return address
                 AND R6, R6, #0
INTIAL_LOOP      AND R0, R0, #0    
                 ST  R0, flag       
                 GETC
                 OUT
                 ST  R0, tmp
                 ADD R0, R0, #-15
                 ADD R0, R0, #-15 
                 ADD R0, R0, #-15   
                 BRz IS_SIGNED
                 JSR CHECK

IS_SIGNED        AND R0, R0, #0
                 ADD R0, R0, #1
                 ST  R0, flag     
                 JSR MAIN_LOOP

MAIN_LOOP        GETC      
                 OUT
                 ST  R0, tmp        
                 ADD R0, R0, #-10   
                 BRz PRE_EXIT   

CHECK            LD  R7, tmp        
                 LD  R0, De_ASCII   
                 ADD R0, R7, R0   
                 BRn ERROR        
                 ADD R0, R0, #-9  
                 BRp ERROR        
         
                 JSR X10_R6         

                 LD  R0, tmp        
                 ST  R6, tmp     
                 LD  R6, De_ASCII    
                 ADD R0, R0, R6    
                 LD  R6, tmp       
                 ADD R6, R6, R0     
                 JSR MAIN_LOOP     

X10_R6           ADD R0, R6, #0     
                 ST  R0, tmp2
                 AND R6, R6, #0  
                 LD  R0, TEN     

X_LOOP           ST  R0, tmp3
                 LD  R0, tmp2       
                 ADD R6, R6, R0    
                 LD  R0, tmp3       
                 ADD R0, R0, #-1   
                 BRp X_LOOP         
                 RET              
            
PRE_EXIT         LD  R0, flag
                 ADD R0, R0, #-1    
                 BRnp EXIT     
                 NOT R6, R6
                 ADD R6, R6, #1    
EXIT             LD  R7, SAVE
                 JMP R7
              
ERROR            LD R0, TEN
                 OUT
                 LEA R0, error
                 PUTS
                 HALT
              
error       .STRINGZ "\nInvalid input, program ended.\n"     
msg         .STRINGZ "Enter number (-32768 to 32767):  "
msg2        .STRINGZ "Outputing number test: Num = "
num         .BLKW x0001
tmp         .BLKW x0001
tmp2        .BLKW x0001  
tmp3        .BLKW x0001
SAVE        .BLKW x0001
TEN         .FILL x000A
De_ASCII    .FILL #-48

OUTPUT        ST  R7, SAVE
              AND R0, R0, #0     ; R0 = 0
              ADD R0, R0, #1
              ST  R0, flag       ; flag = 1, not allow printing 0's until first non-zero digit

              ADD R6, R6, #0        ; R6 unchanged, this line is to apply the brnach condition
              BRzp MAIN_OUTPUT       ; if R6 >= 0, just continue printing the damn number
                
              NOT R6, R6
              ADD R6, R6, #1        ; When R6 < 0,  |R6| = -R6
              LD  R0, De_ASCII      ; R0 = -48
              ADD R0, R0, #3        ; R0 = -45
              NOT R0, R0
              ADD R0, R0, #1        ; R0 = 45 ('-' character)
              OUT                   ; print out hyphen to indicate negative number and then |R6|

MAIN_OUTPUT   LD  R5, VANJ       ; R5 = 10000
              JSR PRINT 
              LD  R5, THOUSAND   ; R5 = 1000
              JSR PRINT
              LD  R5, HUNDRED    ; R5 = 100
              JSR PRINT
              LD  R5, TEN        ; R5 = 10
              JSR PRINT          ; now, R6 should less than 10

              ADD R5, R6, #0     ; set R5 = R6, check if R6 == 0
              BRz LAST_ZERO
              AND R5, R5, #0     ; else print the last non-zero digit
              ADD R5, R5, #1     ; R5 = 1
              JSR PRINT
              LD  R7, SAVE       ; RETURN
              JMP R7                 
              
LAST_ZERO     LD  R0, De_ASCII   ; R0 = -48
              NOT R0, R0 
              ADD R0, R0, #1     ; R0 = 48 (zero)
              OUT
              LD R7, SAVE
              JMP R7        
              

PRINT         ST  R7, SAVE_2
              NOT R5, R5
              ADD R5, R5, #1     ; R5 = -R5
              AND R0, R0, #0
PRINT_LOOP    ADD R0, R0, #1     ; Remainder count
              ST  R6, tmp        ; Save R6 to restore it later
              ADD R6, R6, R5     ; R6 = R6 - R5
              BRzp PRINT_LOOP    ; If R6 >= 0, continue subtracting

              LD  R6, tmp        ; Restore last value of R6 before it results in negative
              ADD R0, R0, #-1    ; Eliminate the last Remainder count that result in negative
              BRnp CONTINUE      ; CONINTUE if R0 is non-zero

              LD  R5, flag       
              ADD R5, R5, #0     ; Because Branch condition only apply for ALU operations
              BRz CONTINUE       ; CONTINUE if flag == 0
              RET                ; Not print out anything, continue the next digit

CONTINUE      AND R5, R5, #0
              ST  R5, flag       ; flag = 0, allow printing 0's
              LD  R5, De_ASCII   ; R5 = -48
              NOT R5, R5
              ADD R5, R5, #1     ; R5 = 48
              ADD R0, R0, R5  
              OUT
              LD  R7, SAVE_2
              JMP R7
  
SAVE_2    .BLKW x0001
flag      .BLKW x0001
HUNDRED   .FILL #100
THOUSAND  .FILL #1000
VANJ      .FILL #10000
.END
